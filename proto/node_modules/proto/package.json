{
  "name": "proto",
  "version": "1.0.9",
  "main": "proto.js",
  "description": "A prototype-based inheritance library that makes it easy to create objects and inheritance hierarchies without losing the power of javascript's prototype system.",
  "keywords": [
    "class",
    "inheritance",
    "prototype",
    "javascript",
    "superclass",
    "parent",
    "child",
    "inherit"
  ],
  "dependencies": {},
  "devDependencies": {
    "deadunit": "",
    "buildModules": "https://github.com/fresheneesz/buildModules/archive/2f50ea0830b0fa580c087b4bfa947de2e7b7d7c3.tar.gz"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/fresheneesz/proto"
  },
  "scripts": {},
  "readme": "\n`proto`\n=====\n\nA prototype-based inheritance/class library that makes it easy to create objects and inheritance hierarchies without losing the\npower of javascript's prototype system.\n\nWhy Use proto?\n==============\n* `instanceof` works with `proto` classes\n* constructors are inheritable\n* non-objects can be returned from a constructor (even `undefined`)!\n* easy access to an object's superclass\n* you don't hafta use the `new` operator\n* native objects work with `proto`. `proto` properly* creates classes that inherit from native objects - even all the `Error` types. *_Inheriting javascript objects has some limitations (see below)_\n* [`prototype` and `constructor` properties][javascriptFunctionProperties] are propertly set\n* `proto` doesn't use `Object.create` so it should work with older browsers ( *testers welcome!* )\n* `proto` is small: ( __896 bytes minified and in AMD format__ )\n* `proto` is lightweight. It doesn't attempt to emulate class-based languages or create any fancy features you probably don't actually need (interfaces, abstract classes, etc)\n\n[javascriptFunctionProperties]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\n\nExample\n=======\n\n```javascript\nvar Person = proto(function() {       // prototype builder\n    this.init = function(legs, arms) {      // constructor\n        this.legs = legs\n        this.arms = arms\n    }\n\n    this.getCaughtInBearTrap = function() { // instance method\n        this.legs -= 1\n    }\n    this.limbs = function() {\n        return this.arms + this.legs\n    }\n})\n\nvar Girl = proto(Person, function() {       // inheritance\n    this.haveBaby = function() {\n        return Person(2,2)\n    }\n})\n\nvar g = Girl(2,2)                          // instantiation\ng.getCaughtInBearTrap()\nconsole.log(\"Girl has \"+g.limbs()+\" limbs\")\nconsole.log(\": (\")\n\nvar newPerson = g.haveBaby()\nconsole.log(\"New person has\" +newPerson.limbs()+\" limbs : )\")\n ```\n\n\nInstall\n=======\n\n```\nnpm install proto\n```\n\n\nUsage\n=====\n\nAccessing proto:\n```javascript\nvar proto = require('proto') // node.js\n\ndefine(['proto'], function(proto) { ... } // amd\n\nproto; // proto.global.js defines proto globally if you really\n       //   want to shun module-based design\n```\n\nUsing proto:\n```javascript\nvar Parent = proto(function() {\n    this.init = function(v) {   // constructor\n        if(v > 0) {\n            this.x = v                // you can normally access the object with this inside methods\n        } else if(v !== undefined) {\n\t\t\treturn true\t              // you can return non-object values\n\t\t} else {\n\t\t\treturn proto.undefined    // return undefined by using a special constructor return value\n\t\t}\n    }\n\n    this.anythingElse = 5   // static properties can be accessed by the class and the instance\n\n\tvar that = this // private functions don't have access to the correct 'this', so pass it in\n    var privateFn = function(me, arg1, etc) {\n        that.x = arg1 + etc\n    }\n    this.doSomething = function() {\n        privateFn(this, this.x, 1)\n    }\n})\n\n// you can inherit from any object!\n// the resulting object factory will generate instances inheriting from:\n    // [if you inherit from]\n        // [a function]: that function's prototype\n        // [anything else]: that object itself\nvar Child = proto(Parent, function(superclass) {\n    this.init = function() {\n        superclass.init.call(this, arguments) // super-class method call\n        this.r = 10\n        return this\n    }\n\n\t// create static methods just like instance methods - you can access them from the constructor\n    this.staticMethod = function(x) {\n        return this.constructor(x+12)        // uses its own constructor to create a Child object\n    }\n})\n\nvar object = Child(1)                // instantiation\nobject.doSomething()                 // method call (as usual)\nvar object2 = Child.staticMethod(1)  // static method call\n\n ```\n\nCreating a custom Error object:\n```javascript\nvar CustomError = proto(Error, function(superclass) {\n    this.name = 'CustomError'\n\n    this.init = function(msg, properties) {\n        superclass.call(this, msg)\n        for(var n in properties) {\n            this[n] = properties[n]\n        }\n    }\n})\n```\n\nLimitations of `proto`\n=============================================\n* Inheriting from `Error` and other exception types doesn't automatically set a correct `name` property, so you need to set it in the contructor manually.\n* Objects inheriting from `String` can't use the `toString` method. \n* Inheriting from `Array` doesn't work.\n* Inheriting from `RegExp` doesn't work either (the results can't use the `test` or `match methods).\n* You can't properly access any non-writable properties of a function from the returned proto-object factory though the properties will work correctly on instances. This includes: `name`, `length`, `arguments`, and `caller`.\n* Some properties are read-only and so can't be reset on the prototype object. An example is `name` on firefox.\n\nTodo\n====\n* Browser testing\n * Chrome [ ]\n * Firefox [ ]\n * IE10 [ ]\n * IE9 [ ]\n * IE8 [ ]\n * Opera [ ]\n\nHow to Contribute!\n============\n\nAnything helps:\n\n* Creating issues (aka tickets/bugs/etc). Please feel free to use issues to report bugs, request features, and discuss changes\n* Updating the documentation: ie this readme file. Be bold! Help create amazing documentation!\n* Submitting pull requests.\n\nHow to submit pull requests:\n\n1. Please create an issue and get my input before spending too much time creating a feature. Work with me to ensure your feature or addition is optimal and fits with the purpose of the project.\n2. Fork the repository\n3. clone your forked repo onto your machine and run `npm install` at its root\n4. If you're gonna work on multiple separate things, its best to create a separate branch for each of them\n5. edit!\n6. If it's a code change, please add to the unit tests (at test/protoTest.js) to verify that your change\n7. When you're done, run the unit tests and ensure they all pass\n8. Commit and push your changes\n9. Submit a pull request: https://help.github.com/articles/creating-a-pull-request\n\nContributors\n============\n* Special thanks to [jayferd][jayferd], since I got most of the unit tests for `proto` from [his `pjs` project][pjs].\n\n\n[jayferd]: https://github.com/jayferd\n[pjs]: https://github.com/jayferd/pjs\n\nChange Log\n=========\n\n* 1.0.8 - if a static property can't be written (because it's read only or for some other reason throws an exception when being set), it will now silently not set, instead of throwing an exception\n* 1.0.7 - getting rid of useless line in stack trace\n* 1.0.6 - fixing custom error name in stacktraces\n* 1.0.5 - fixing github dependencies\n\nLicense\n=======\nReleased under the MIT license: http://opensource.org/licenses/MIT",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fresheneesz/proto/issues"
  },
  "homepage": "https://github.com/fresheneesz/proto",
  "_id": "proto@1.0.9",
  "_shasum": "249b2dcf1b47db0f8a79abba474fd10747e9eb1c",
  "_from": "proto@",
  "_resolved": "https://registry.npmjs.org/proto/-/proto-1.0.9.tgz"
}
